#ifndef __SUPOS_CPP_VECTOR
#define __SUPOS_CPP_VECTOR

#include <cstddef>
#include <memory>
#include <assert.h>
#include <utility>
#include <new>
//#include <algorithm>
#include <stdio.h>
#include <string>

namespace std{
    template < class T, class Alloc = allocator<T> >
    class vector{
    public :
        typedef T value_type;
        typedef Alloc allocator_type;
        typedef T* pointer;
        typedef const T* const_pointer;
        typedef T& reference;
        typedef const T& const_reference;
        typedef size_t size_type;
        typedef pointer iterator;
        typedef const T* const_iterator;

    private :
        Alloc _alloc;
        pointer _data;
        size_type _size;
        size_type _capacity;

        inline size_type strategy(size_type s){
            size_t res = 1 << (8*sizeof(size_t) - __builtin_clz(s+1)+1);
            if(res) return res;
            else return s;
        }
        inline void destroy(pointer input,size_t nb){
            for(size_t i = 0 ; i < nb ; ++i){
                input[i].~value_type();
            }
        }


    public :
        explicit vector (const allocator_type& alloc = allocator_type())
            :_alloc(alloc),_data(nullptr),_size(0),_capacity(0){
        }
        explicit vector (size_type n) : _alloc(){
            _size = n;
            _capacity = strategy(n);
            _data = _alloc.allocate(_capacity);
            for(size_t i = 0 ; i < n ; ++i){
                _data[i].T();
            }
        }
        vector (const vector& oth): _alloc(oth._alloc),_data(nullptr),
                                    _size(0),_capacity(0){
            reserve(oth._size);
            _size = oth._size;
            for(int i =0 ; i < _size;++i){
                _data[i] = oth._data[i];
            }
        }
        vector (vector&& oth): _alloc(move(oth._alloc)),_data(oth._data),
                                     _size(oth._size),_capacity(oth._capacity){
            oth._data = nullptr;
            oth._size = 0;
            oth._capacity = 0;
        }

        vector (size_type n, const value_type& val,
                const allocator_type& alloc = allocator_type());

        ~vector(){
            if(_size && _data){
                for(size_t i = 0 ; i < _size ; ++i){
                    _data[i].~value_type();
                }
            }
            //printf("Destructed elem in %p \n",_data);
            //    for(volatile int i = 0 ; i < 500000000 ; ++ i);
            if(_data) _alloc.deallocate(_data,_capacity);
            //printf("Destructed area \n");
            //for(volatile int i = 0 ; i < 500000000 ; ++ i);
        }

        vector& operator= (const vector& x){
            if(_data){
                for(size_t i = 0 ; i < _size ; ++i){
                    _data[i].~value_type();
                }
            }
            reserve(x.size());
            for(size_t i = 0 ; i < x._size ; ++ i){
                _data[i] = x._data[i];
            }
            _size = x._size;
            return *this;
        }
        vector& operator= (vector&& x){
            this->~vector();
            this->vector(move(x));
            return *this;
        }
        reference operator [](size_type i){
            return _data[i];
        }
        const_reference operator [](size_type i)const{
            return _data[i];
        }
        reference at(size_type i){
            assert(i < _size && "At assert failed");
            return _data[i];
        }
        size_type size(){
            return _size;
        }
        void reserve(size_type size){
            if (_size>0 && size <= _capacity) return;
            size_type capacity = strategy(size);
            pointer data = _alloc.allocate(capacity);
            if(_data){
                for(int i = 0 ; i < _size ; ++i){
                    data[i] = move(_data[i]);
                }
                _alloc.deallocate(_data,_capacity);
            }
            _capacity = capacity;
            _data = data;
        }
        void push_back (const value_type& val){
            reserve(_size+1);
            new(&_data[_size]) T(val);
            ++_size;
        }
        iterator begin(){
            return _data;
        }
        iterator end(){
            return _data + _size;
        }
        const_iterator begin() const{
            return _data;
        }
        const_iterator end()const {
            return _data + _size;
        }
        const_iterator cbegin()const{
            return _data;
        }
        const_iterator cend()const{
            return _data + _size;
        }
        iterator erase (iterator first, iterator last){
            size_type diff = last - first;
            if(!diff)return end();
            move(last,_data+_size,first);
            _size -= diff;
            return first;

        }
        iterator erase (iterator position){
            erase(position,position+1);
        }
        void pop_back(){
            assert(_size > 0 && "pop_back on empty vector");
            --_size;
            _data[_size].~value_type();
        }
        bool empty() const{
            return _size == 0;
        }
        iterator insert (const_iterator position, const value_type& val){
            //printf("vector insert %p %p!\n",position,end());
            //for(volatile int i = 0 ; i < 100000000 ; ++i);
            if(position == end()){
                push_back(val);
                return end()-1;
            }
            if(_capacity == _size){
                //printf("way 1");
                size_t capacity = strategy(_size +1);
                size_t diff = position-_data;
                pointer data = _alloc.allocate(capacity);
                for(pointer it = _data ; it < position ; ++it){
                    new (data + (it-_data)) T(move(*it));
                }
                //move(const_iterator(_data),position,data);
                for(const_pointer it = position ; it < _data + _size ; ++it){
                    new (data + (it-_data)+1) T(move(*it));
                }
                //move(position,const_iterator(_data + _size),data + diff +1);
                new (data + diff) T(val);
                _capacity = capacity;
                _data = data;
                ++_size;
                return _data + diff;
            }
            else{
                assert(_capacity > _size);
                iterator newpos = const_cast<iterator>(position);
                //printf("way 2 %d %d %p %p\n",_capacity, _size , newpos,_data + _capacity);
                new(_data +_size) T();
                move_backward(newpos,_data + _size,_data + _size +1);
                *newpos = val;
                ++_size;
                //printf ("Yeah !\n");
                return newpos;
            }
            //return begin();
        }
        void clear(){
            //printf("Clearing\n");
            //for(volatile int i  = 0 ; i < 300000000 ; ++i);
            this->~vector();
            //printf("Cleared\n");
            //for(volatile int i  = 0 ; i < 300000000 ; ++i);
            _data = nullptr;
            _size = 0;
            _capacity = 0;
        }
    };
}
#endif
